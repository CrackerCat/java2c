global_uses core.dependency.check

function dependency_requiresProgram()
{
	local -r programName="$1"
	shift 1
	local operatingSystem
	for operatingSystem in "$@"
	do
		:
	done
}

dependency_functions=()

function dependency_ensureWeAreRunningBash4()
{
	if [ ${BASH_VERSINFO[0]} != "4" ]; then
		global_message FAIL "$ourName: You are not running bash 4."
	fi
}
dependency_functions+=(dependency_ensureWeAreRunningBash4)

# Also MACHTYPE
# Also HOSTTYPE
# Also OSTYPE
# Also uname -s
# See Gnu shtool http://www.gnu.org/software/shtool/ (slow)
# See Gnu config.guess http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob;f=config.guess;hb=HEAD (yuck)
# See uname -s list at wikipedia https://en.wikipedia.org/wiki/Uname
dependency_osFamily=''
function dependency_determineOsFamily()
{
	case "$OSTYPE" in
		
		cygwin)
			dependency_osFamily=cygwin
		;;
		
		# eg linux-gnu
		linux*)
			dependency_osFamily=linux
		;;
		
		# Part of MinGW, eg Git Bash and msysGit
		msys)
			dependency_osFamily=msys
		;;
		
		# darwin12 [Mountain Lion], darwin9.0 [Leopard]
		darwin*)
			dependency_osFamily=macosx
		;;
		
		# ?
		solaris*)
			dependency_osFamily=solaris
		;;
		
		# ?
		# netbsd is known; freebsd et al are guesses
		netbsd|freebsd|openbsd)
			dependency_osFamily=bsd
		;;
		
		*)
			dependency_osFamily="$OSTYPE"
		;;
		
	esac
	
	# the ostype windows is also reserved but isn't obviously useful
}
dependency_functions+=(dependency_determineOsFamily)

function dependency_determineDistributionName()
{
	local dependency_check_function
	for dependency_check_function in "${dependency_check_functions[@]}"
	do
		if $dependency_check_function; then
			return 0
		fi
	done
	
	if which lsb_release 1>/dev/null 2>/dev/null; then
		local -r lsbDistributor="$(lsb_release --id --short)"
		if [ -n "$lsbDistributor" ]; then
			readonly dependency_distributionName="$lsbDistributor"
			return 0
		fi
	fi
	
	global_message FAIL "Could not determine distribution"
}
dependency_functions+=(dependency_determineDistributionName)

function dependency_setUpAliases()
{
	local -r pathsFile="$global_configPath"/paths.d/"$dependency_distributionName".path
	if [ ! -f "$pathsFile" ]; then
		return 0
	fi
	
	# changing PATH clears the hash table - remember!
	# current design DOES NOT set up a suitable path environment for fork'd programs, eg cmake
	
	# enable hashing
	set -h
	
	declare -A unaliasedBinaries
	declare -A installPackages
	local packageName
	local binaryName
	local absolutePath
	while IFS=' ' read -r packageName binaryName absolutePath
	do
		if [ -x "$absolutePath" ]; then
			hash -p "$absolutePath" "$binaryName"
		else
			if [ "$packageName" = "zzz-built-in" ]; then
				global_message FAIL "Essential binary $binaryName not in expected path $absolutePath and no installation is possible"
			fi
			unaliasedBinaries["${binaryName}"]="$absolutePath"
			installPackages["${packageName}"]=1
		fi
	done <"$pathsFile"
	
	if [ ${#installPackages[@]} -ne 0 ]; then
		global_message WARN "Installing missing packages ${!installPackages[@]}"
		dependency_check_${dependency_distributionName}_packageManager "${!installPackages[@]}"
		for binaryName in "${!unaliasedBinaries[@]}"
		do
			absolutePath="${unaliasedBinaries["${binaryName}"]}"
			hash -p "$absolutePath" "$binaryName"
		done
	fi
	
}
dependency_functions+=(dependency_setUpAliases)

function dependency_installDependencies()
{
	local dependency_function
	for dependency_function in "${dependency_functions[@]}"
	do
		$dependency_function
	done
}
