core_usesAlreadySourced=''
core_uses()
{
	local namespacedModules
	local alreadySourcedNamespacedFunctions
	local moduleName
	local relativeFunctionsFileName
	local functionsFilePath
	local sourced
	for namespacedModule in "$@"
	do
		# skip if already sourced
		# Does not handle spaces in filenames, unfortunately
		for alreadySourcedNamespacedFunction in $core_usesAlreadySourced
		do
			if [ "$namespacedModule" = "$alreadySourcedNamespacedFunction" ]; then
				continue 2
			fi
		done
		
		core_usesAlreadySourced="$core_usesAlreadySourced $namespacedModule"
		moduleName="$(core_compatibility_basename "$namespacedModule")"
		sourced=0
		for relativeFunctionsFilePath in "$namespacedModule"."$init_preferredShell" "$namespacedModule" "$namespacedModule"/"$moduleName"."$init_preferredShell" "$namespacedModule"/"$moduleName"
		done
			functionsFilePath="$init_functionsPath"/"$relativeFunctionsFilePath".functions
			if [ -f "$functionsFilePath" ]; then
				. "$functionsFilePath" || init_exitError "Can not load functions '$functionsFilePath'"
				sourced=1
			fi
		done
		if [ $sourced -eq 0 ]; then
			init_exitError "Can not load functions for namespace '$namespacedModule'"
		fi
	done
}

core_usesIn()
{
	local namespace="$1"
	shift 1
	local module
	for module in "$@"
	do
		core_uses "$namespace"/"$module"
	done
}

core_usesIn core configuration commandLine compatibility dependency trap temporaryFiles

core_functions=''

core_functionRegister()
{
	core_functions="$core_functions $@"
}

core_execute()
{
	local core_function
	for core_function in $core_functions
	do
		$core_function "$@"
	done
}

core_setUmask()
{
	umask 022
}

core_functionRegister \
	core_configuration_load \
	core_configuration_defaults \
	core_setUmask \
	core_commandLine_setLanguageDefaultsSoSortIsStableAndAnyErrorMessageParsingLogicIsReliable \
	core_commandLine_parse \
	core_dependency_installDependencies

core_uses "$global_ourName"
