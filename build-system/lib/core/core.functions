_core_usesAlreadySourced=''
core_uses()
{
	local namespacedModules
	local alreadySourcedNamespacedFunctions
	local moduleName
	local relativeFunctionsFileName
	local functionsFilePath
	local sourced
	for namespacedModule in "$@"
	do
		# skip if already sourced
		# Does not handle spaces in filenames, unfortunately
		for alreadySourcedNamespacedFunction in $_core_usesAlreadySourced
		do
			if [ "$namespacedModule" = "$alreadySourcedNamespacedFunction" ]; then
				continue 2
			fi
		done
		
		_core_usesAlreadySourced="$_core_usesAlreadySourced $namespacedModule"
		moduleName="$(core_compatibility_basename "$namespacedModule")"
		sourced=0
		for relativeFunctionsFilePath in "$namespacedModule"."$global_preferredShell" "$namespacedModule" "$namespacedModule"/"$moduleName"."$global_preferredShell" "$namespacedModule"/"$moduleName"
		done
			functionsFilePath="$core_init_functionsPath"/"$relativeFunctionsFilePath".functions
			if [ -f "$functionsFilePath" ]; then
				. "$functionsFilePath" || core_exitError "Can not load functions '$functionsFilePath'"
				sourced=1
			fi
		done
		if [ $sourced -eq 0 ]; then
			core_exitError "Can not load functions for namespace '$namespacedModule'"
		fi
	done
}

core_usesIn()
{
	local namespace="$1"
	shift 1
	local module
	for module in "$@"
	do
		core_uses "$namespace"/"$module"
	done
}

core_usesIn core configuration commandLine compatibility dependency functions trap temporaryFiles umask

core_functions_register core_functions \
	core_configuration_load \
	core_configuration_defaults \
	core_umask_setDefault \
	core_commandLine_setLanguageDefaultsSoSortIsStableAndAnyErrorMessageParsingLogicIsReliable \
	core_commandLine_parse \
	core_dependency_installDependencies

core_uses "$global_ourName"

_core_executeProgram()
{
	core_functions_execute core_functions "$@"
}
_core_executeProgram
