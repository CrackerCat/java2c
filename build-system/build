#!/usr/bin/env bash
set -e

global_main()
{
	# dash by default escapes backslashes, other echos behave differently. This way is defensive.
	global_echo()
	{
		printf '%s\n' "$1"
	}

	# The purpose of global_dirname and global_basename is to provide internal implementations of logic we can't be 100%
	# sure of exists in the environment or is implemented as we would like for critical pieces of code.
	# Such a critical piece is code executed before and during command line arg parsing
	global_dirname()
	{
		local converted="${1%/*}"
		if [ "$converted" = "$1" ]; then
			printf '%s' '.'
		else
			printf '%s' "$converted"
		fi
	}
	
	global_basename()
	{
		printf '%s' "${1##*/}"
	}
	
	global_message()
	{
		local messageKind="$1"
		local message="$2"
	
		case "$messageKind" in
		
			WARN|FAIL|PASS)
				global_echo "$global_ourName: $messageKind: $message" 1>&2
			;;
		
			INFO)
				if [ $global_verbosity -gt 0 ]; then
					global_echo "$global_ourName: $messageKind: $message" 1>&2
				fi
			;;
		
			DEBUG)
				if [ $global_verbosity -gt 1 ]; then
					global_echo "$global_ourName: $messageKind: $message" 1>&2
				fi
			;;
		
			*)
				global_echo "$global_ourName: $messageKind: $message" 1>&2
				exit 3
			;;
	
		esac
	}

	global_exitError()
	{
		global_message FAIL "$1"
		exit 1
	}

	global_exitHelp()
	{
		global_helpMessage 1>&2
		exit 2
	}

	global_helpMessage()
	{
		printf '%s' "${global_ourName}
$_program_helpMessage_description

Usage 1: ${global_ourName} -h|--help
Usage 2: ${global_ourName} [-v|--verbose]${_program_helpMessage_optionsAndNonOptions}

Usages
    1       Show Help
    2       $_program_helpMessage_usageMessage

Options without Argments
    Switch  Long-Switch  Explanation            Default
    -h      --help       show this help
    -v      --verbose    be more verbose        ${global_verbosity}"

		if [ -n "$_program_helpMessage_argumentedOptions" ]; then
			printf '%s' "$_program_helpMessage_argumentedOptions"
		else
			printf '\n'
		fi
	
		if [ -n "$_program_helpMessage_argumentlessOptions" ]; then
			printf '%s' "Options with Arguments
Switch  Default
$_program_helpMessage_argumentlessOptions"
		else
			:
		fi
	
		if [ -n "$_program_helpMessage_nonOptionArguments" ]; then
			printf '%s' "Non-Options
$_program_helpMessage_nonOptionArguments
Specify -- before the non-options to separate them from option arguments"
		fi

		printf '%s' "
Path Files
A path file is used to define the location of essential programs used during initial bootstrapping. It also defines a packageManager
to automatically install any missing dependencies. Paths are used if a file <global_configPath>/paths.d/<distributionName>
exists for the detected <distributionName>. Additional path files are used for a chosen backend.
"
	}
	
	global_setTracing()
	{
		case "$-" in
			
			*x*)
				export global_bash_tracing="yes"
			;;
			
			*)
				if [ -n "$global_bash_tracing" ]; then
					if [ "$global_bash_tracing" = "yes" ]; then
						set -x
					fi
				fi
			;;
			
		esac
	}
	
	_global_resolveSymlink()
	{
		local potentialSymlink="$0"
		while readlink "$potentialSymlink" 1>/dev/null
		do
			potentialSymlink="$(readlink "$potentialSymlink")"
		done
		_global_resolveSymlink_result="$potentialSymlink"
	}
	
	global_findOurName()
	{
		readonly global_ourSymlinkName="$(global_basename "$0")"
		
		local _global_resolveSymlink_result
		_global_resolveSymlink
		
		readonly global_ourName="$(global_basename "$_global_resolveSymlink_result")"
	}
	
	_global_builtInDoesNotExist()
	{
		local builtInName="$1"
		local value="$(PATH='' command -v "$builtInName")"
		if [ "$builtInName" = "$value" ]; then
			return 1
		fi
		return 0
	}
	
	global_addMissingBuiltins()
	{
		# bash, zsh are known to support this
		if _global_builtInDoesNotExist pushd; then
			
			if ! _global_builtInDoesNotExist popd; then
				global_exitError "Weird shell does not have pushd but does have popd (?feature detection bug?)!"
			fi
			
			global_pushdCount=0

			pushd()
			{
				local path="$1"
				eval "global_pushdStack${global_pushdCount}='$(pwd)'"
				global_pushdCount=$((global_pushdCount+1))
				cd "$path" 1>/dev/null
			}

			popd()
			{
				global_pushdCount=$((global_pushdCount-1))
				eval "local path=\"\$global_pushdStack${global_pushdCount}\""
				eval "unset global_pushdStack${global_pushdCount}"
				cd "$path" 1>/dev/null
			}
		
		else
			
			pushd()
			{
				builtin pushd "$@" 1>/dev/null
			}
		
			popd()
			{
				builtin popd "$@" 1>/dev/null
			}
			
		fi
		
		# bash, zsh are known to support this
		if _global_builtInDoesNotExist source; then
			
			source()
			{
				. "$@"
			}
			
		fi
	}
	
	global_setSaneEnvironmentDefaults()
	{
		set +o allexport
		set +o emacs
		set -o errexit
		set +o ignoreeof
		set +o monitor
		set +o noclobber
		set +o noexec
		set +o noglob
		set +o nolog
		set +o notify
		set +o nounset
		set +o verbose
		set +o vi
		
		# unset will fail if, and only if, we've been source'd and they have been made readonly. Unlikely.
		
		# MUST be unset before making use of cd - which is needed for the dash / sh 'pushd' replacement, which in turn is needed by global_findOurPath
		unset CDPATH
		unset HISTSIZE
		unset MAILCHECK
		unset MAILPATH
		
		# bash specific, but since at this stage of execution we can't be sure we're running under bash, we do nothing
		unset BASH_ENV
		unset BASH_XTRACEFD
		unset ENV
		unset FCEDIT
		unset FIGNORE
		unset FUNCNEST
		unset GLOBIGNORE
		unset HISTCONTROL
		unset HISTFILE
		unset HISTFILESIZE
		unset HISTIGNORE
		unset HISTTIMEFORMAT
		unset HOSTFILE
		unset IGNOREEOF
		unset INPUTRC
		unset MAIL
		unset TMOUT
	}

	global_findOurPath()
	{
		pushd "$(global_dirname "$0")"
			readonly global_ourSymlinkPath="$(pwd)"
		popd
		
		local _global_resolveSymlink_result
		_global_resolveSymlink
		
		pushd "$(global_dirname "$_global_resolveSymlink_result")"
			readonly global_ourPath="$(pwd)"
		popd
	}
	
	# We can not determine the interpreter running us (short of using lsof with $$ and awk) in a simple, reliable way
	# So instead we exec ourselves once, using our process id as a check against user environment interference
	# Common bash-isms and bugs in dash https://wiki.ubuntu.com/DashAsBinSh
	# Shell workarounds FAQ http://cfajohnson.com/shell/cus-faq-2.html#Q11
	# dash echo escapes output, yuck, with no -E, it seems
	# https://stackoverflow.com/questions/3199893/howto-detect-bash-from-shell-script  - lsof -p $$ is probably best, but lsof and awk are dependencies - so we just rexec
	global_rexecUnderCorrectShell()
	{
		if [ "$global_shell_rexecing" = "$$" ]; then
			# we've been successfully re-exec'd
			unset global_shell_rexecing
		else
			# exec -a doesn't work in dash
			global_shell_rexecing=$$ exec "$global_ourSymlinkPath"/"$global_ourSymlinkName" "$@"
		fi
	}
	
	global_determinePreferredShell()
	{
		read -r shebang_path shebang_shell <"$0"

		if [ "$shebang_path" = '#!/usr/bin/env' ]; then
			if [ -z "$shebang_shell" ]; then
				global_exitError "All shell scripts run under env should use 'env' with a shell"
			fi
			global_preferredShell="$shebang_shell"
		else
			global_preferredShell="$(global_basename "$shebang_path")"
		fi
	}
	
	# There's a bug it dash that means that if a set -o fails, we can't stop it even with || true or set +e!
	global_setSaneOptions()
	{
		# dash fails here regardless of set -e, so this code MUST run after re-exec'd shell
		if [ "$global_preferredShell" = 'bash' ]; then
			set -o braceexpand
			set +o errtrace
			set +o functrace
			set +o hashall
			set +o histexpand
			set +o history
			set -o interactive-comments
			set +o keyword
			set +o onecmd
			set +o physical
			set +o pipefail
			set +o posix
		fi
	}
	
	_global_initialiseGlobalConfiguration()
	{
		global_configPath="$global_ourPath"/config
		global_functionsPath="$global_ourPath"/functions
		# can be en_GB.UTF-8 or 'C' (but that's not unicode aware)
		# A more sophisticated scheme would use locale -a and hunt for an UTF-8 locale
		global_language='en_US.UTF-8'
		global_verbosity=0
	}

	global_initialiseConfiguration()
	{
		_global_initialiseGlobalConfiguration
		_program_initialiseConfiguration
	}
	
	global_loadAnyConfiguration()
	{
		:
	}
	
	global_usesAlreadySourced=''
	global_uses()
	{
		local namespacedFunctions
		local alreadySourcedNamespacedFunctions
		local moduleName
		local relativeFunctionsFileName
		local functionsFilePath
		local sourced
		for namespacedFunction in "$@"
		do
			# skip if already sourced
			# Does not handle spaces in filenames, unfortunately
			for alreadySourcedNamespacedFunction in $global_usesAlreadySourced
			do
				if [ "$namespacedFunction" = "$alreadySourcedNamespacedFunction" ]; then
					continue 2
				fi
			done
			
			global_usesAlreadySourced="$global_usesAlreadySourced $namespacedFunction"
			moduleName="$(global_basename "$namespacedFunction")"
			sourced=0
			for relativeFunctionsFilePath in "$namespacedFunction"."$global_preferredShell" "$namespacedFunction" "$namespacedFunction"/"$moduleName"."$global_preferredShell" "$namespacedFunction"/"$moduleName"
			do
				functionsFilePath="$global_functionsPath"/"$relativeFunctionsFilePath".functions
				if [ -f "$functionsFilePath" ]; then
					source "$functionsFilePath" || global_exitError "Can not load functions '$functionsFilePath'"
					sourced=1
				fi
			done
			if [ $sourced -eq 0 ]; then
				global_exitError "Can not load functions for namespace '$namespacedFunction'"
			fi
		done
	}

	global_setTracing
	global_findOurName
	global_addMissingBuiltins
	global_setSaneEnvironmentDefaults
	global_findOurPath
	global_rexecUnderCorrectShell "$@"
	global_determinePreferredShell
	global_setSaneOptions
	global_initialiseConfiguration
	global_loadAnyConfiguration
	
	global_uses core
	core_program_execute "$@"
}

_program_helpMessage_description="Builds projects using CMake"
_program_helpMessage_optionsAndNonOptions=" -- [build_projects...]"
_program_helpMessage_usageMessage="Build projects"
_program_helpMessage_argumentedOptions=""
_program_helpMessage_argumentlessOptions=""
_program_helpMessage_nonOptionArguments="build_projects is a list of projects to build"

_program_initialiseConfiguration()
{
	pushd "$global_ourSymlinkPath"/source 1>/dev/null
		build_sourcePath="$(pwd)"
	popd 1>/dev/null
	
	# May not exist
	build_outputPath="$global_ourSymlinkPath"/output
}

_program_parseCommandLineLongOption()
{
	case "$OPTARG" in
		
		*)
			global_parseCommandLine_longOptionUnknown
		;;
		
	esac
}

_program_parseCommandLineShortOption()
{
	case "$option" in
		
		*)
			:
		;;
		
	esac
}

_program_parseNonOptionArguments()
{
	if [ $# -eq 0 ]; then
		global_exitError "No projects specified"
	fi
	
	# TODO: Not sh friendly, and objects violently if dash as a syntax error!
	# Problem is we want to preserve in an array if using bash 4...
	#build_projects=("$@")
}

global_main "$@"
