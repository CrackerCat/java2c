#!/usr/bin/env bash
set -e

global_main()
{
	global_message()
	{
		local messageKind="$1"
		local message="$2"
	
		case "$messageKind" in
		
			WARN|FAIL|PASS)
				echo "$global_ourName: $messageKind: $message" 1>&2
			;;
		
			INFO)
				if [ $global_verbosity -gt 0 ]; then
					echo "$global_ourName: $messageKind: $message" 1>&2
				fi
			;;
		
			DEBUG)
				if [ $global_verbosity -gt 1 ]; then
					echo "$global_ourName: $messageKind: $message" 1>&2
				fi
			;;
		
			*)
				echo "$global_ourName: $messageKind: $message" 1>&2
				exit 3
			;;
	
		esac
	}

	# The purpose of these functions is to provide internal implementations of logic we can't be 100%
	# sure of exists in the environment or is implemented as we would like for critical pieces of code.
	# Such a critical piece is code executed before and during command line arg parsing
	global_dirname()
	{
		local converted="${1%/*}"
		if [ "$converted" = "$1" ]; then
			echo "."
		else
			echo "$converted"
		fi
	}
	
	global_basename()
	{
		echo "${1##*/}"
	}

	global_exitError()
	{
		global_message FAIL "$1"
		exit 1
	}

	global_exitHelp()
	{
		global_helpMessage 1>&2
		exit 2
	}

	global_helpMessage()
	{
		echo -E "${global_ourName}
$_program_helpMessage_description

Usage 1: ${global_ourName} -h|--help
Usage 2: ${global_ourName} [-v|--verbose]${_program_helpMessage_optionsAndNonOptions}

Usages
    1       Show Help
    2       $_program_helpMessage_usageMessage

Options without Argments
    Switch  Long-Switch  Explanation            Default
    -h      --help       show this help
    -v      --verbose    be more verbose        ${global_verbosity}"

		if [ -n "$_program_helpMessage_argumentedOptions" ]; then
			echo -E "$_program_helpMessage_argumentedOptions"
		else
			echo -E ""
		fi
	
		if [ -n "$_program_helpMessage_argumentlessOptions" ]; then
			echo -E "Options with Arguments
Switch  Default
$_program_helpMessage_argumentlessOptions"
		else
			:
		fi
	
		if [ -n "$_program_helpMessage_nonOptionArguments" ]; then
			echo -E "Non-Options
$_program_helpMessage_nonOptionArguments
Specify -- before the non-options to separate them from option arguments"
		fi

		echo -E "
Path Files
A path file is used to define the location of essential programs used during initial bootstrapping. It also defines a packageManager
to automatically install any missing dependencies. Paths are used if a file <global_configPath>/paths.d/<distributionName>
exists for the detected <distributionName>. Additional path files are used for a chosen backend.
"
	}
	
	global_setTracing()
	{
		# is set -x on?
		if [[ "$-" == *x* ]]; then
			export global_bash_tracing="yes"
		elif [ ! -z "$global_bash_tracing" ]; then
			if [ "$global_bash_tracing" = "yes" ]; then
				set -x
			fi
		fi
	}
	
	_global_resolveSymlink()
	{
		local potentialSymlink="$0"
		while readlink "$potentialSymlink" 1>/dev/null
		do
			potentialSymlink="$(readlink "$potentialSymlink")"
		done
		_global_resolveSymlink_result="$potentialSymlink"
	}
	
	global_findOurName()
	{
		readonly global_ourSymlinkName="$(global_basename "$0")"
		
		local _global_resolveSymlink_result
		_global_resolveSymlink
		
		readonly global_ourName="$(global_basename "$_global_resolveSymlink_result")"
	}
	
	# Common bash-isms and bugs in dash https://wiki.ubuntu.com/DashAsBinSh
	# Shell workarounds FAQ http://cfajohnson.com/shell/cus-faq-2.html#Q11
	# dash echo escapes output, yuck, with no -E, it seems
	global_detectShell()
	{
		read -r shebang_path shebang_shell <"$0"

		if [ "$shebang_path" = '/usr/bin/env' ]; then
			if [ -z "$shebang_shell" ]; then
				global_exitError "All shell scripts run under env should use 'env' with a shell"
			fi
			global_shell="$shebang_shell"
		else
			global_shell="$(global_basename "$shebang_path")"
		fi
	}
	
	global_rejectShells()
	{	
		case "$global_shell" in
			
			rbash)
				global_exitError "The shell '$global_shell' is explicitly not supported"
			;;
			
			# busybox is a dash derivative
			ash|dash)
				global_exitError "The shell '$global_shell' should not be specified in the she-bang"
			;;
			
			# tcsh is the default choice on FreeBSD, DragonFlyBSD and DesktopBSD. Unlikely that code would have worked to this point.
			csh|tcsh)
				global_exitError "C shells such as '$global_shell' are not supported"
			;;
			
			sh|bash)
				:
			;;
			
			*)
				global_exitError "The shell '$global_shell' is not known"
			;;
			
		esac
	}
	
	global_addMissingBuiltins()
	{
		if [ "$global_shell" = 'sh' ]; then
			
			global_pushdCount=0

			pushd()
			{
				local path="$1"
				eval "global_pushdStack${global_pushdCount}='$(pwd)'"
				global_pushdCount=$((global_pushdCount+1))
				cd "$path" 1>/dev/null
			}

			popd()
			{
				global_pushdCount=$((global_pushdCount-1))
				eval "local path=\"\$global_pushdStack${global_pushdCount}\""
				eval "unset global_pushdStack${global_pushdCount}"
				cd "$path" 1>/dev/null
			}
			
		fi
	}
	
	global_setSaneEnvironmentDefaults()
	{
		if [ "$global_shell" = 'bash' ]; then
			set -o braceexpand
			set +o errtrace
			set +o functrace
			set +o hashall
			set +o histexpand
			set +o history
			set -o interactive-comments
			set +o keyword
			set +o onecmd
			set +o physical
			set +o pipefail
			set +o posix
		fi
		
		set +o allexport
		set +o emacs
		set -o errexit
		set +o ignoreeof
		set +o monitor
		set +o noclobber
		set +o noexec
		set +o noglob
		set +o nolog
		set +o notify
		set +o nounset
		set +o verbose
		set +o vi

		unset CDPATH
		unset HISTSIZE
		unset MAILCHECK
		unset MAILPATH

		if [ "$global_shell" = 'bash' ]; then
			unset BASH_ENV
			unset BASH_XTRACEFD
			unset ENV
			unset FCEDIT
			unset FIGNORE
			unset FUNCNEST
			unset GLOBIGNORE
			unset HISTCONTROL
			unset HISTFILE
			unset HISTFILESIZE
			unset HISTIGNORE
			unset HISTTIMEFORMAT
			unset HOSTFILE
			unset IGNOREEOF
			unset INPUTRC
			unset MAIL
			unset TMOUT
		fi
		umask 022
	}

	global_findOurPath()
	{
		pushd "$(global_dirname "$0")" >/dev/null
			readonly global_ourSymlinkPath="$(pwd)"
		popd >/dev/null
		
		local _global_resolveSymlink_result
		_global_resolveSymlink
		
		pushd "$(global_dirname "$_global_resolveSymlink_result")" >/dev/null
			readonly global_ourPath="$(pwd)"
		popd >/dev/null
	}
	
	_global_initialiseGlobalConfiguration()
	{
		global_configPath="$global_ourPath"/config
		global_functionsPath="$global_ourPath"/functions
		global_verbosity=0
	}

	global_initialiseConfiguration()
	{
		_global_initialiseGlobalConfiguration
		_program_initialiseConfiguration
	}

	global_loadAnyConfiguration()
	{
		:
	}

	global_parseCommandLine_longOption()
	{
		longOptionValue="${!OPTIND}"
		OPTIND=$((OPTIND+1))
		longOptionName="$OPTARG"
	}

	global_parseCommandLine_longOption_noValue()
	{
		global_parseCommandLine_longOption
		if [ -n "$longOptionValue" ]; then
			global_exitError "The --${longOptionName} option does not take arguments (eg '${longOptionValue}')"
		fi
	}

	global_parseCommandLine_longOptionEquals()
	{
		longOptionValue="${OPTARG#*=}"
		longOptionName="${OPTARG%=$longOptionValue}"
	}

	global_parseCommandLine_longOptionEquals_noValue()
	{
		global_parseCommandLine_longOptionEquals
		if [ -n "$longOptionValue" ]; then
			global_exitError "The --${longOptionName} option does not take arguments (eg '${longOptionValue}')"
		fi
	}
	
	global_parseCommandLine_longOptionUnknown()
	{
		if [ "$OPTERR" = 1 ] && [ "${optspec:0:1}" != ":" ]; then
			global_exitError "Invalid option --${OPTARG}"
		fi
	}
	
	global_parseCommandLine()
	{
		local -r getoptsStringExtra="$1"
		local -r getoptsString=":hv-:${getoptsStringExtra}"

		local OPTERR=1
		local OPTIND=1
		local OPTARG
		local option
		local longOptionValue
		local longOptionName
		while getopts "$getoptsString" option
		do
			# https://stackoverflow.com/questions/402377/using-getopts-in-bash-shell-script-to-get-long-and-short-command-line-options/7680682
			case "$option" in
			
				-)
					case "$OPTARG" in
					
						help)
							global_parseCommandLine_longOption_noValue
							global_exitHelp
						;;
					
						help=*)
							global_parseCommandLine_longOptionEquals_noValue
						;;
					
						verbose)
							global_parseCommandLine_longOption_noValue
							global_verbosity=$((global_verbosity+1))
						;;
					
						verbose=*)
							global_parseCommandLine_longOptionEquals_noValue
						;;
					
						*)
							_program_parseCommandLineLongOption
						;;
					
					esac
				;;
			
				h)
					global_exitHelp
				;;
			
				v)
					global_verbosity=$((global_verbosity+1))
				;;
			
				'?')
					global_exitError "Invalid option -${OPTARG}"
				;;
			
				*)
					_program_parseCommandLineShortOption
				;;
			
			esac
		done
		
		shift $((OPTIND - 1))
		_program_parseNonOptionArguments "$@"
	}
	
	# TODO: Not sh friendly
	#global_usesAlreadySourced=()
	global_uses()
	{
		while [ $# -ne 0 ]
		do
			local functionFileName="$1"
		
			local alreadySourcedFunctionFileName
			local -i sourced=0
			for alreadySourcedFunctionFileName in "${global_usesAlreadySourced[@]}"
			do
				if [ "$alreadySourcedFunctionFileName" = "$functionFileName" ]; then
					sourced=1
					break
				fi
			done
			if [ $sourced -eq 1 ]; then
				continue
			fi
			build_global_usesAlreadySourced+=("$functionFileName")
			
			local dotsToPathSlashes="${functionFileName//.//}"
			local functionsFilePath="$global_functionsPath"/"$dotsToPathSlashes".functions
			local functionsShellSpecificFilePath="$global_functionsPath"/"$dotsToPathSlashes"."$global_shell".functions
			if [ -f "$functionsFilePath" ]; then
				source "$functionsFilePath"
				if [ -f "$functionsShellSpecificFilePath" ]; then
					source "$functionsShellSpecificFilePath"
				fi
				local autoload="$global_functionsPath"/"$dotsToPathSlashes"
				if [ -d "$autoload" ]; then
					pushd "$autoload" 1>/dev/null
					
						for functionsFilePath in *.functions
						do
							local withoutFunctionsExtension="${functionsFilePath%.*}"
							local withoutShellExtensionIfAny="${withoutFunctionsExtension%.*}"
							if [ "$withoutShellExtensionIfAny"."$global_shell".functions = "$functionsFilePath" ]; then
								# Is a shell function file - ignore
								:
							else
								source "$functionsFilePath"
								local shellExtensionFunctionFilePath="$withoutFunctionsExtension"."$global_shell".functions
								if [ -f "$shellExtensionFunctionFilePath" ]; then
									source "$shellExtensionFunctionFilePath"
								fi
							fi
						done
				
					popd 1>/dev/null
				fi
			else
				local finalPiece="$(global_basename "$dotsToPathSlashes")"
				functionsFilePath="$global_functionsPath"/"$dotsToPathSlashes"/"$finalPiece".functions
				functionsShellSpecificFilePath="$global_functionsPath"/"$dotsToPathSlashes"/"$finalPiece"."$global_shell".functions
				source "$functionsFilePath"
				if [ -f "$functionsShellSpecificFilePath" ]; then
					source "$functionsShellSpecificFilePath"
				fi
			fi
			shift 1
		done
	}

	global_setTracing
	global_findOurName
	global_detectShell
	global_rejectShells
	global_addMissingBuiltins
	global_setSaneEnvironmentDefaults
	global_findOurPath
	global_initialiseConfiguration
	global_loadAnyConfiguration
	global_parseCommandLine "$@"
	
	global_uses core
	core_dependency_installDependencies
	
	global_uses main
	core_program_execute
}

_program_helpMessage_description="Builds projects using CMake"
_program_helpMessage_optionsAndNonOptions=" -- [build_projects...]"
_program_helpMessage_usageMessage="Build projects"
_program_helpMessage_argumentedOptions=""
_program_helpMessage_argumentlessOptions=""
_program_helpMessage_nonOptionArguments="build_projects is a list of projects to build"

_program_parseCommandLineLongOption()
{
	case "$OPTARG" in
		
		*)
			global_parseCommandLine_longOptionUnknown
		;;
		
	esac
}

_program_parseCommandLineShortOption()
{
	case "$option" in
		
		*)
			:
		;;
		
	esac
}

_program_parseNonOptionArguments()
{
	if [ $# -eq 0 ]; then
		global_exitError "No projects specified"
	fi
	# TODO: Not sh friendly, and objects violently if dash as a syntax error!
	build_projects=("$@")
}

# TODO: Not sh friendly
_program_initialiseConfiguration()
{
	# TODO: Not sh friendly
	pushd "$global_ourSymlinkPath"/source 1>/dev/null
		build_sourcePath="$(pwd)"
	popd 1>/dev/null
	# May not exist
	build_outputPath="$global_ourSymlinkPath"/output
}

global_main "$@"
