#!/usr/bin/env dash

init_init()
{
	set -e
	set -u

	# Early as possible to stop users running shell scripts as setuid / setgid
	# Not a perfect defence as exported functions can have replaced builtin, set, etc...
	# And $0 might not be a path to this script
	if [ -u "$0" ]; then
		builtin echo "We can not be run with setuid (set user id) set"
		builtin exit 1
	fi
	if [ -g "$0" ]; then
		builtin echo "We can not be run with setgid (set group id) set"
		builtin exit 1
	fi

	readonly init_libraryName=shellfire
	# depends_on readlink, stat
}
init_init

core_compatibility_basename()
{
	printf '%s' "${1##*/}"
}

core_compatibility_indirectVariableValue()
{
	eval "printf '%s' \"\$$1\""
}

core_compatibility_testVariableIsUnset()
{
	local variableName="$1"
	local evaluate="[ \"\${$variableName+unset}\" != 'unset' ]"
	eval "$evaluate"
}

core_compatibility_testVariableIsSet()
{
	! core_compatibility_testVariableIsUnset "$1"
}

core_compatibility_setVariableIfUnset()
{
	local variableName="$1"
	local variableDefaultValue="$2"
	
	# This is not whitespace-safe: eval "$variableName=\"\${$variableName-$variableDefaultValue}\""
	if core_compatibility_testVariableIsUnset "$variableName"; then
		eval "$variableName='$variableDefaultValue'"
	fi
}

global_compatibility_which()
{
	command -v "$1"
}

global_compatibility_whichNoOutput()
{
	global_compatibility_which "$1" 1>/dev/null 2>/dev/null
}

init_message()
{
	local messageKind="$1"
	local message="$2"
	
	local shouldEcho
	case "$messageKind" in
	
		FAIL)
			shouldEcho=1
		;;
		
		WARN)
			shouldEcho=1
		;;
	
		INFO)
			if [ $init_verbosity -gt 0 ]; then
				shouldEcho=1
			fi
		;;
	
		DEBUG)
			if [ $init_verbosity -gt 1 ]; then
				shouldEcho=1
			fi
		;;
	
		*)
			shouldEcho=1
		;;

	esac
	
	if [ $shouldEcho -eq 1 ]; then
		printf '%s\n' "$global_ourName: $messageKind: $message" 1>&2
	fi
}

init_exitError()
{
	init_message FAIL "$1"
	exit 1
}

init_setSaneEnvironmentDefaults()
{
	set +o allexport
	set +o emacs
	set -o errexit
	set +o ignoreeof
	set +o monitor
	set +o noclobber
	set +o noexec
	set +o noglob
	set +o nolog
	set +o notify
	set -o nounset
	set +o verbose
	set +o vi
	
	# unset will fail if, and only if, we've been source'd and they have been made readonly. Unlikely.
	
	# MUST be unset before making use of cd
	unset CDPATH
	unset HISTSIZE
	unset MAILCHECK
	unset MAILPATH
	unset ENV
	
	# bash specific, but since at this stage of execution we can't be sure we're running under bash, we do nothing
	unset BASH_ENV
	unset BASH_XTRACEFD
	unset FCEDIT
	unset FIGNORE
	unset FUNCNEST
	unset GLOBIGNORE
	unset HISTCONTROL
	unset HISTFILE
	unset HISTFILESIZE
	unset HISTIGNORE
	unset HISTTIMEFORMAT
	unset HOSTFILE
	unset IGNOREEOF
	unset INPUTRC
	unset MAIL
	unset TMOUT
}

# http://mywiki.wooledge.org/BashFAQ/028 on $0
# http://mywiki.wooledge.org/Bashism?action=show&redirect=bashism
# realpath vs readlink, and supported OS (comments): https://unix.stackexchange.com/questions/136494/whats-the-difference-between-realpath-and-readlink-f
init_findOurNameAndPath()
{
	readonly global_ourSymlinkName="$(core_compatibility_basename "$0")"
	
	# Temporary assignment
	global_ourName="$global_ourSymlinkName"
	
	# can be empty if 'bash file' used or 'bash </path/to/file' or ksh with PATH containing '.'
	local potential_global_ourSymlinkPath="${0%/*}"
	if [ -z "$potential_global_ourSymlinkPath" ]; then
		init_exitError "Do not invoke this program either by specifying a shell interpreter on a file in the current working directory (eg bash '$0') or redirecting from a pipe into a shell interpreter (eg bash [-c] <'$0') or by using ksh with a PATH containing '.'"
	fi
	
	# At this point, we resolve $0 vs the current working directory
	# If we were exec'd, we have either a relative or an absolute path
	cd "$potential_global_ourSymlinkPath" 1>/dev/null
		readonly global_ourSymlinkPath="$(pwd)"
	cd - >/dev/null
	
	cd -P "$potential_global_ourSymlinkPath" 1>/dev/null
		readonly global_ourPath="$(pwd)"
	cd - >/dev/null
	
	# We can only follow symlinks with readlink (which doesn't work if $0 ends in \n)
	# readlink is not on AIX, some Solaris
	# realpath is quite rare, unfortunately, as it is perfectly suited (but it is in coreutils, so will become more common)
	if global_compatibility_whichNoOutput readlink; then
		local potentialSymlink="$0"
		while readlink "$potentialSymlink"
		do
			potentialSymlink="$(readlink "$potentialSymlink")"
		done
		readonly global_ourName="$(core_compatibility_basename "$potentialSymlink")"
	elif global_compatibility_whichNoOutput realpath; then
		readonly global_ourName="$(core_compatibility_basename "$(realpath "$0")")"
	else
		readonly global_ourName="$global_ourSymlinkName"
	fi
}

init_setTracing()
{
	case "$-" in
		
		*x*)
			export ${global_ourName}_bash_tracing="yes"
		;;
		
		*)
			if core_compatibility_testVariableIsSet ${global_ourName}_bash_tracing; then
				case "$(core_compatibility_indirectVariableValue "${global_ourName}_bash_tracing")" in
				
					yes)
						set -x
					;;
					
					no)
						set +x
					;;
			
				esac
			fi
		;;
		
	esac
}

init_determinePreferredShell()
{
	local shebang_path
	local shebang_shell
	local remainder
	local comment
	local shebang_path
	
	IFS=' ' read -r commented_shebang_path shebang_shell remainder <"$global_ourSymlinkPath"/"$global_ourSymlinkName"
	if [ -n "$remainder" ]; then
		init_exitError "Passing options to a shell ('#!$shebang_path $shebang_shell $remainder') is not supported"
	fi
	IFS='!' read -r comment shebang_path <<-EOF
		$commented_shebang_path
	EOF
	
	if [ -z "$shebang_shell" ]; then
		init_preferredShell="$(core_compatibility_basename "$shebang_path")"
	else
		if [ "$shebang_path" != '/usr/bin/env' ]; then
			init_exitError "All shell scripts should use '/usr/bin/env' with a shell, not #!$shebang_path $shebang_shell"
		fi
		init_preferredShell="$shebang_shell"
	fi
}

# Ensures we run under a shell interpreter that we were designed for - no matter what is specified in the shebang
# This works around packaging tools that want '#!/bin/bash', but point to an old version. Needs to be coupled into loading new shell versions.
init_rexecUnderCorrectShell()
{
	if core_compatibility_testVariableIsSet init_shell_rexecing; then
		if [ "$init_shell_rexecing" = "$$" ]; then
			# we've been successfully re-exec'd
			unset init_shell_rexecing
			return 0
		fi
	fi
	
	if ! global_compatibility_whichNoOutput "$init_preferredShell"; then
		init_exitError "Preferred shell '$init_preferredShell' does not exist on the PATH"
	fi
	local shellPath="$(global_compatibility_which "$init_preferredShell")"
	
	# exec -a doesn't work in dash
	init_shell_rexecing=$$ exec "$shellPath" "$global_ourSymlinkPath"/"$global_ourSymlinkName" "$@"
}

# goal is to create three forms of executable
# * one that is completely standalone, including paths files [but can still make use of overrides]
# * one that is completely standalone, excluding paths files and with functions in /lib
#   * possible variant that shares functions? ?why? creates unnecesary version tensions, requires ABI compat, etc - a bit like shared libraries today
#   * if not the above, then init_functionsPath
# * one that can run from checkout of git & git submodules

# paths files are composable
# * work simply by combining those defined in shellfire with local choices
# * allow local, git friendly, replacements OR additions

# first two forms are going to require a kind of build process
init_main()
{
	init_setSaneEnvironmentDefaults
	init_findOurNameAndPath
	init_setTracing
	init_determinePreferredShell
	init_rexecUnderCorrectShell "$@"
	# the only reason this is called before sourcing core is because we need to ensure init_functionsPath is valid
	core_configuration_load
	
	. "$init_functionsPath"/core/core.functions
	core_execute "$@"
}
init_main "$@"
